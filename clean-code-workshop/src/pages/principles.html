<section>
    <section>
        <h2>Des principes</h2>
        <ul>
            <li>KISS</li>
            <li>DRY</li>
            <li>YAGNI</li>
            <li>SLAP</li>
            <li>SOLID</li>
            <li>...</li>
        </ul>
    </section>
    <section>
        <h2>KISS</h2>
        <p>Keep It Simple Stupid</p>
        <aside class="notes">
            <ul>
                <li>Garder les choses simples</li>
                <li>Lisible</li>
                <li>Maintenable</li>
                <li>Testable</li>
                <li>...</li>
            </ul>
        </aside>
    </section>
    <section>
        <h2>DRY</h2>
        <p>Don't repeat yourself</p>
        <aside class="notes">
            <ul>
                <li>Ne vous répétez pas</li>
                <li><b>/!\</b> Attention : peut provoquer une sur factorisation</li>
            </ul>
        </aside>
    </section>
    <section>
        <h2>YAGNI</h2>
        <p>You Ain't Gonna Need It</p>
        <aside class="notes">
            <ul>
                <li>code évolutif</li>
                <li>ne pas anticiper les évolutions</li>
                <li>anticipation
                    <ul>
                        <li>plus de complexité</li>
                        <li>code mort</li>
                        <li>mauvaise anticipation</li>
                        <li>code legacy</li>
                    </ul>
                </li>
            </ul>
        </aside>
    </section>
    <section>
        <h2>SLAP</h2>
        <p>Single Layer Abstraction Principle</p>
        <aside class="notes">
            <ul>
                <li>Je ne vois qu'une couche</li>
                <li>pas de métier dans les DAO</li>
                <li>+ réutilisabilité</li>
                <li>+ testable</li>
                <li>+ lisible</li>
            </ul>
        </aside>
    </section>
    <section>
        <h2>SOLID</h2>
        <ul>
            <li><b>S</b>ingle responsibility principle</li>
            <li><b>O</b>pen close principle</li>
            <li><b>L</b>iskov substitution</li>
            <li><b>I</b>nterface segregation</li>
            <li><b>D</b>ependency inversion</li>
        </ul>
    </section>
    <section>
        <h2>Single Responsability Principle</h2>
        <pre class="fragment fade-in"><code>
public void sendGreetings(String fileName, XDate xDate,
String smtpHost, int smtpPort)
throws IOException, ParseException,
AddressException, MessagingException {

    BufferedReader in = new BufferedReader(new FileReader(fileName));
    String str = "";
    str = in.readLine(); // skip header
    while ((str = in.readLine()) != null) {
        // parse line
        String[] employeeData = str.split(", ");
        Employee employee = new Employee(employeeData[1], employeeData[0],
                        employeeData[2], employeeData[3]);
        if (employee.isBirthday(xDate)) {
            // Send mail
            String recipient = employee.getEmail();
            String body = "Happy Birthday, dear %NAME%"
                            .replace("%NAME%", employee.getFirstName());
            String subject = "Happy Birthday!";
            sendMessage(smtpHost, smtpPort, "sender@here.com",
            subject, body, recipient);
        }
    }
}
    </code></pre>
        <aside class="notes">
            <ul>
                <li>parsing fichier</li>
                <li>Envoie mail</li>
                <li>Création mail</li>
                <li>filtre des employé</li>
                <li>Je ne peux rien réutiliser</li>
                <li>Je devrais dupliquer</li>
            </ul>
        </aside>
    </section>
    <section>
        <h2>Open / close principle</h2>
        <pre class="fragment fade-in"><code>
public double Area(Object[] shapes) {
    double area = 0;
    foreach (Shape shape : shapes) {
        if (shape instanceof Rectangle) {
            Rectangle rectangle = (Rectangle) shape;
            area += rectangle.getWidth() * rectangle.getHeight();
        }
        else {
            Circle circle = (Circle) shape;
            area += circle.getRadius() * circle.getRadius() * Math.PI;
        }
    }
    return area;
}
    </code></pre>
        <aside class="notes">
            <ul>
                <li>obligé de modifier pour ajouter une forme</li>
                <li>je vais oublier</li>
                <li>je n'aurais pas d'erreur si j'oublie</li>
                <li>parsing fichier</li>
            </ul>
        </aside>
    </section>
    <section>
        <h2>Liskov substitution</h2>
        <pre class="fragment fade-in"><code>
public class Rectangle {
    private int width;
    private int height;
    public void setWidth(int width) { this.width = width; }
    public void setHeight(int height) { this.height = height; }
}

public class Carre extends rectangle {
    private int side;
    public void setWidth(int width) { this.side = width; }
    public void setHeight(int height) { this.side = height; }
}

rectange.setHeight(4);
rectange.setHeight(5);
    </code></pre>
        <aside class="notes">
            <ul>
                <li>une implementation doit être remplacable par n'importe quel implémentation</li>
                <li>ex : HashMap, TreeMap</li>
                <li>interface = contrat</li>
                <li>ici : carré etend de rectangle</li>
                <li>mais carré n'a qu'une donnée side</li>
                <li>carré ne respecte pas le contrat de rectangle</li>
                <li>provoque des comportements étrange</li>
            </ul>
        </aside>
    </section>
    <section>
        <h2>Interface segregation</h2>
        <pre class="fragment fade-in"><code>
public class User {
    private String firstname;
    private String lastname;
    private String email;
    private List&lt;Item&gt; purchasedItems;
    private ShoppingCart shoppingCart;
    private PaymentDetails paymentDetails;
}
    </code></pre>
        <aside class="notes">
            <p>User a l'air d'être complet cependant il n'a pas une forte cohésion.</p>
            <p>En effet purchasedItems va être utiliser pour la recommandation</p>
            <p>shoppingCart et paymentDetails pour la finalisation de la commande</p>
            <p>Il sera impossible de relocaliser ces données (ex: purchasedItems dans une basse doc) sans un gros Travail
                de refacto</p>
        </aside>
    </section>
    <section>
        <h2>Dependency inversion</h2>
        <pre class="fragment fade-in"><code>
public class DatasourcePoolWatcher {

    EventLogWriter writer = null;

    public void Notify(String message) {
        if (writer == null) {
            writer = new EventLogWriter();
        }
        writer.write(message);
    }
}
    </code></pre>
        <aside class="notes">
            <p>Je ne peux pas changer EventLogWriter par une autre classe</p>
            <p>ex: EmailNotifier</p>
        </aside>
    </section>
</section>